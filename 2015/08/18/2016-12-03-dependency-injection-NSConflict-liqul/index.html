<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Dependency Injection · Liqun's Homepage</title><meta name="description" content="Dependency Injection - Liqun Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="liqul.github.io/blog/atom.xml" title="Liqun's Homepage"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://scholar.google.com/citations?user=icgetesAAAAJ&amp;hl=en" target="_blank" class="nav-list-link">GOOGLE SCHOLAR</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/liqunli/" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Dependency Injection</h1><div class="post-info">Aug 18, 2015</div><div class="post-content"><p>面向对象的一条准则就是将类与类之间的依赖关系解耦，这并不是什么新概念。Dependency Injection（DI）的目的也是一样，引用《implementing laravel》的一句原文：</p>
<blockquote>
<p>Dependency Injection is the act of adding (injecting) any dependencies into a class, rather than instantiating them somewhere within the class code itself. </p>
</blockquote>
<p>举一个例子来区分这两种情况：</p>
<pre class="lang:php decode:true ">class NoDI 
{
    function __construct()
    {
        $this->inner_class = new InnerClass();
    }
}</pre> 

<p><pre class="lang:php decode:true ">class DI<br>{<br>    function __construct(SomeInterface $implementation)<br>    {<br>        $this-&gt;inner_class = $implementation;<br>    }<br>}</pre><br>上面前一种情况下，如果inner_class的实现发生变化，例如需要重写一个NewInnerClass()，那么需要在NoDI中修改这行代码。而后一种情况下，由于inner_class是从外部传入的，所以DI类本身不需要发生任何变化。</p>
<p>这个道理并不新颖，所以乍一眼看来这没有什么有意思的东西。如果无论什么情况都需要为类额外写一个interface，反倒是一种负担。另外，如果类之间的依赖关系比较复杂，使用起来也不方便，例如：类A依赖类B，类B又依赖类C，那么如果要获取一个A的对象，需要先得到B的对象，进一步递推到C的对象。</p>
<p>为了减少这种重复的实例化过程，Laravel提供了Container。实际上一个Laravel的APP对象本身就继承自Container。还是以A、B、C之间的依赖关系为例：</p>
<p><pre class="lang:php decode:true "><br>interface B_Interface {}<br>interface C_Interface {}</pre></p>
<p>class A {<br>    function __construct(B_Interface $b){}<br>}</p>
<p>class B implements B_Interface {<br>    function __construct(C_Interface $c){}<br>}</p>
<p>class C implements C_Interface {<br>    function __construct(){}<br>}<br><br>在没有Container的情况下，会像下面一样来实例化A对象：</p>
<p><pre class="lang:php decode:true "><br>$c = new C();<br>$b = new B($c);<br>$a = new A($b);<br></pre><br>试想我们每次获取A对象都需要写这样的3行代码。在面向对象的开发中，类之间的依赖关系是非常复杂的，这使得这样实例化变得不可行。这或许是许多人更加倾向于面向过程来开发（即使他们的代码里也充满了类定义）。</p>
<p>有了Container以后这样的情况得到了很大的改善。如下面所示：</p>
<p><pre class="lang:php decode:true "><br>APP::bind(‘B_Interface’, ‘B’);</pre></p>
<p>APP::bind(‘C_Interface’, function(){<br>    return new C();<br>});</p>
<p>$a = APP::make(‘A’);<br><br>在Laravel中，上面的代码会这样执行：</p>
<p><ol><br>    <li>尝试实例化类A，发现其依赖B_Interface</li><br>    <li>尝试找到实现B_Interface的类，发现已注册的B_Interface指向B类</li><br>    <li>尝试实例化类B，发现其依赖C_Interface</li><br>    <li>尝试找到实现C_Interface的类，发现已注册的C_Interface执行一个closure，返回一个C类对象</li><br>    <li>按照上面相反的顺序依次获得C、B、A对象</li><br></ol><br>Laravel自动完成上面这样的递归式实例化过程。在PHP中，只要利用反射就能做到这一点。也许有人会说，上面这样的代码岂止3行，比前面的实现更加麻烦了。但是，在真实的场景下，两个bind语句是由服务提供方来实现的，而且只要做一次，在全局都能使用。所以，其实只需要最后一句话就够了。</p>
<p>上面的例子里，生成实现B_Interface的类的时候用的是：</p>
<p><pre class="lang:php decode:true "><br>APP::bind(‘B_Interface’, ‘B’);<br></pre><br>但对于C_Interface，用的是closure。这样做是由于B依赖于C_Interface，如果也用closure的话就不方便写了。</p>
<p>Container在Laravel处于绝对核心地位。可以说所有类实例化都是经过Container来完成的，上面举的例子其实只是一种用法而已，在使用Laravel的过程中，由于Container的存在还有非常多技巧。</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/2015/09/07/2016-12-03-rabbitmq-error1-NSConflict-liqul/" class="prev">PREV</a><a href="/blog/2015/08/15/2016-12-03-rabbitmq-memory-management-NSConflict-liqul/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2018 <a href="liqul.github.io/blog">Liqun Li</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>