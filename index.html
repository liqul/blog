<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Liqun's Homepage</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon2.jpeg"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="liqul.github.io/blog/atom.xml" title="Liqun's Homepage"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon2.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives" target="_self" class="nav-list-link">TAGS/ARCHIVE</a></li><li class="nav-list-item"><a href="/blog/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/credit-spread/" class="post-title-link">金融概念学习——信用利差（credit spread）</a></h2><div class="post-info">Mar 6, 2019</div><div class="post-content"><p>不同债券的利率是不一样的，为什么呢？想想如果5年国债的收益率是3%，那么一个企业发行一种5年的债券，它的利率应该定在多少？显然要高于3%，否则傻子才去买，因为企业是可能违约的，而国家会违约吗？所以，不同债券的利率本来就该不一样。</p></div><a href="/blog/credit-spread/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/news/" class="post-title-link">新闻纪录</a></h2><div class="post-info">Jan 3, 2019</div><div class="post-content"><p>每天读新闻，学习思考一些基本的经济逻辑。</p></div><a href="/blog/news/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/etcd_raft_4/" class="post-title-link">Raft协议实现学习之—写入过程</a></h2><div class="post-info">Nov 23, 2018</div><div class="post-content"><p>在上一篇文章重点梳理了选举的过程，而这一篇想着重梳理一下写入的过程。仍然沿着节点初始化的日志开始： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 阶段7：节点1成为leader后向其它节点广播MsgApp</span></span><br><span class="line">17:40:19 1-&gt;2 MsgApp Term:2 Log:1/3 Commit:3 Entries:[2/4 EntryNormal <span class="string">""</span>]</span><br><span class="line">17:40:19 3-&gt;1 MsgVoteResp Term:2 Log:0/0</span><br><span class="line">17:40:19 INFO: raft.node: 2 elected leader 1 at term 2</span><br><span class="line">17:40:19 1-&gt;3 MsgApp Term:2 Log:1/3 Commit:3 Entries:[2/4 EntryNormal <span class="string">""</span>]</span><br><span class="line">17:40:19 2-&gt;1 MsgAppResp Term:2 Log:0/4 <span class="comment"># 这里2汇报已经保存了新的entry</span></span><br><span class="line">17:40:19 INFO: raft.node: 3 elected leader 1 at term 2</span><br><span class="line">17:40:19 1-&gt;2 MsgApp Term:2 Log:2/4 Commit:4 <span class="comment"># 在这里commit从3变成4</span></span><br><span class="line">17:40:19 3-&gt;1 MsgAppResp Term:2 Log:0/4 </span><br><span class="line">17:40:19 node 1: processing entry: &#123;2 4 EntryNormal [] []&#125; <span class="comment"># 由于已经确认大部分节点都保存成功，可以apply到state machine</span></span><br><span class="line">17:40:19 1-&gt;3 MsgApp Term:2 Log:2/4 Commit:4</span><br><span class="line">17:40:19 2-&gt;1 MsgAppResp Term:2 Log:0/4</span><br><span class="line">17:40:19 node 2: processing entry: &#123;2 4 EntryNormal [] []&#125; <span class="comment"># 2在接收到来自1的MsgApp后得知commit=4，可以apply到本地的state machie</span></span><br><span class="line">17:40:19 3-&gt;1 MsgAppResp Term:2 Log:0/4</span><br><span class="line">17:40:19 node 3: processing entry: &#123;2 4 EntryNormal [] []&#125;</span><br></pre></td></tr></table></figure></div><a href="/blog/etcd_raft_4/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/multiraft/" class="post-title-link">从Raft到MultiRaft</a></h2><div class="post-info">Nov 1, 2018</div><div class="post-content"><p>Raft是一种共识算法，在之前的文章里已经提到过。简而言之，每次集群处理一次请求，都需要经过集群中大部分节点协商。所以一个Raft集群的规模一般不会太大，否则协商的代价就会比较大。那么如果希望基于Raft实现一些规模比较大的服务该怎么扩展呢？</p></div><a href="/blog/multiraft/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/banks/" class="post-title-link">《人为制造的脆弱性》--读后感</a></h2><div class="post-info">Sep 20, 2018</div><div class="post-content"><p>断断续续读了一遍《人为制造的脆弱性》。作者在第一部分里已经基本讲明了自己的观点，后面几部分只是列举一些国家佐证自己的论点，所以我也只重点看了前面前两个部分，后面的部分大致翻看了几眼。这本书现在可以在网上<a href="https://yuedu.baidu.com/ebook/9d86229dcd22bcd126fff705cc175" target="_blank" rel="noopener">直接看</a>。</p>
<p>刚开始读的时候就被前两段话吸引了，一个好的开头的确能起到吸引读者的作用，贴在下面：</p>
<blockquote>
<p>每个人都知道生活是不公平的，即所谓“政治在起作用”。当最钟爱的电影痛失奥斯卡奖时，我们会这样说；当办公室最底层的蠢人陪领导打高尔夫而获得了本应属于我们的升职机会时，我们会这么说；当发现一座毫无用途的大桥得以建成，仅仅是因为某个很有权势的参议员将联邦基础设施建设资金带回了家乡时，我们会这么说；当发现一个有关系的企业家获得数百亿政府补贴去组建一个根本不可能有竞争力的公司时，我们也会这么说。</p>
</blockquote></div><a href="/blog/banks/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/etcd_raft_3/" class="post-title-link">Raft协议实现学习之—初始化和Leader Election过程</a></h2><div class="post-info">Sep 13, 2018</div><div class="post-content"><h2 id="实验代码和输出"><a href="#实验代码和输出" class="headerlink" title="实验代码和输出"></a>实验代码和输出</h2><p>实验代码是基于作者<a href="http://github.com/otm/raft-part-1" target="_blank" rel="noopener">原来的代码</a>稍微修改而来，main函数如下所示:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	nodes = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// start a small cluster</span></span><br><span class="line">	nodes[<span class="number">1</span>] = newNode(<span class="number">1</span>, []raft.Peer&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">	<span class="keyword">go</span> nodes[<span class="number">1</span>].run()</span><br><span class="line"></span><br><span class="line">	nodes[<span class="number">2</span>] = newNode(<span class="number">2</span>, []raft.Peer&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">	<span class="keyword">go</span> nodes[<span class="number">2</span>].run()</span><br><span class="line"></span><br><span class="line">	nodes[<span class="number">3</span>] = newNode(<span class="number">3</span>, []raft.Peer&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">	<span class="keyword">go</span> nodes[<span class="number">3</span>].run()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for leader election</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><a href="/blog/etcd_raft_3/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/etcd_raft_2/" class="post-title-link">Raft协议实现学习之—etcd/raft库的使用</a></h2><div class="post-info">Sep 13, 2018</div><div class="post-content"><h1 id="Etcd中的Raft协议实现"><a href="#Etcd中的Raft协议实现" class="headerlink" title="Etcd中的Raft协议实现"></a>Etcd中的Raft协议实现</h1><p>Etcd里Raft协议的实现的在<a href="https://github.com/etcd-io/etcd/tree/master/raft" target="_blank" rel="noopener">这里</a>。etcd并不是Raft的唯一实现，事实上Raft协议有<a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">许多实现</a>，还有我简单尝试过的<a href="https://github.com/atomix/" target="_blank" rel="noopener">atomix</a>。选择etcd/raft是因为个人对etcd和go语言比较感兴趣，而且Raft论文里提到的实现方法恰好比较适合用go语言的goroutine来实现。</p>
<p>另外的一个原因正如etcd/raft在github上的readme所说：</p>
<blockquote>
<p>To keep the codebase small as well as provide flexibility, the library only implements the Raft algorithm; both network and disk IO are left to the user. Library users must implement their own transportation layer for message passing between Raft peers over the wire. Similarly, users must implement their own storage layer to persist the Raft log and state.</p>
</blockquote></div><a href="/blog/etcd_raft_2/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/etcd_raft_1/" class="post-title-link">Raft协议实现学习之—概览</a></h2><div class="post-info">Sep 13, 2018</div><div class="post-content"><h1 id="Raft协议概览"><a href="#Raft协议概览" class="headerlink" title="Raft协议概览"></a>Raft协议概览</h1><h2 id="Raft是什么？"><a href="#Raft是什么？" class="headerlink" title="Raft是什么？"></a>Raft是什么？</h2><p>Raft是一种共识协议。与Raft完成相同任务的系统有Chubby和Zookeeper，以及一些系统内置的完成类似功能的组件，例如Elasticsearch里的Zen-Discovery。简而言之，共识协议的目的是让一组节点在响应外界输入时能表现的像一个节点一样。共识系统往往应用于有主备结构的存储系统中，如果缺少这种协议，就无法避免数据<a href="http://www.bailis.org/blog/when-does-consistency-require-coordination/" target="_blank" rel="noopener">错误</a>。</p></div><a href="/blog/etcd_raft_1/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/flink/" class="post-title-link">Reading "State Management in Apache Flink"</a></h2><div class="post-info">Sep 9, 2018</div><div class="post-content"><div class="tip"><br>Updated on 2018-09-09<br></div>

<p>I’m playing with Flink (1.6) and Structured Streaming (2.3.1) recently. I’m no expert for either framework, so my opinion is based on my very short experience with each of them. </p></div><a href="/blog/flink/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/things-about-replication-in-elasticsearch/" class="post-title-link">Things about replication in Elasticsearch</a></h2><div class="post-info">Apr 18, 2018</div><div class="post-content"><div class="tip"><br>Updated on 2018-04-18<br></div>

<p>Elasticsearch is evolving fast in the past few years. There have been quite some discussions on data loss during node crashes, which can be found <a href="https://github.com/elastic/elasticsearch/issues/10933" target="_blank" rel="noopener">here</a> and <a href="https://github.com/elastic/elasticsearch/issues/14252" target="_blank" rel="noopener">here</a>. Most of the issues have been fixed as described <a href="https://www.elastic.co/guide/en/elasticsearch/resiliency/current/index.html" target="_blank" rel="noopener">here</a>. However, since Elasticsearch carried out a major upgrade to version 5+, some serious issues still remain for low versions, e.g., the stale replica problem described <a href="https://github.com/elastic/elasticsearch/issues/14671" target="_blank" rel="noopener">here</a>. </p></div><a href="/blog/things-about-replication-in-elasticsearch/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/blog/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2019 <a href="liqul.github.io/blog">Liqun Li</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>