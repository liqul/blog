<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Notes on HBase · Liqun's Homepage</title><meta name="description" content="Notes on HBase - Liqun Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon2.jpeg"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="liqul.github.io/blog/atom.xml" title="Liqun's Homepage"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon2.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives" target="_self" class="nav-list-link">TAGS/ARCHIVE</a></li><li class="nav-list-item"><a href="/blog/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Notes on HBase</h1><div class="post-info">Apr 17, 2018</div><div class="post-content"><p>So far as I know, HBase is the first open source “table” style storage in the big data scope. It is an implementation of the <a href="https://research.google.com/archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">BigTable paper</a> presented by Google. If you read the paper or the <a href="https://hbase.apache.org/book.html" target="_blank" rel="noopener">reference guide</a>, HBase does not look like a table. The paper tells you that it is a </p>
<blockquote>
<p>sparse, distributed, persistent, multidimensional sorted map.</p>
</blockquote>
<a id="more"></a>
<p>There are so many details in this definition. If you want to find out what each of these terms means, you can go through this <a href="https://dzone.com/articles/understanding-hbase-and-bigtab" target="_blank" rel="noopener">article</a>. After reading it, you’d rather call HBase a map, instead of a table, because the data structure is</p>
<blockquote>
<p>(row key, column family:qualifier, timestamp) -&gt; value</p>
</blockquote>
<p>From the perspective of RDBM, each table in HBase could still be thought of as, for example, a table in MySQL. Data is organized into rows and each row is composed of columns (grouped into column families). A cell is specified by its row key and column name. So far, everything is the same with RDBM. You can insert rows, manipulate fields within a row, retrieve a row by its row key, and so on. The <strong>timestamp</strong> is actually an internal concept, <a href="https://www.ngdata.com/bending-time-in-hbase" target="_blank" rel="noopener">which should not be used by the user</a> or even put in the data model. In fact, timestamp is used as a version number. Therefore, to the user, there are still two dimensions (row and column) like in an ordinary RDBM table. </p>
<p>HBase has been out there for quite a few years, so it is not hard to find a good introduction about what is going on inside. This <a href="https://mapr.com/blog/in-depth-look-hbase-architecture/" target="_blank" rel="noopener">blog</a> has really nice diagrams. It covers comprehensively some of the most important building blocks of HBase, which I’d like to elaborate a few below. </p>
<h3><span id="data-organization">Data Organization</span></h3><p>Each row in a HBase table is break into cells for persistence. And each cell is in fact a key-value pair, where the key is (row key, column family:qualifier, timestamp). Data is first written to a memory cache called MemStore. Once the MemStore accumulates enough data, the data is flushed into a persistent file called HFile. Both data in the MemStore and in the HFile are sorted by their keys. Each flush may generate more than one HFiles. Each row of data is break down by defined column families. For instance, if the table is with two column families, each flush will get two separate HFiles. </p>
<p>A row is not stored as a whole, especially if the row has been manipulated later after insertion. Therefore, each time the client read a row, HBase goes through the MemStore and maybe, a few HFiles to bring together all fields to assemble the row. This is called the <strong>read amplification</strong> problem. </p>
<p>HBase keeps its metadata inside a special HBase table called METADATA. The metadata maintains a set of pointers where the key is a three-value tuple [table, region start key, region id] and the value is the RegionServer. If the client wants to find a specific row key, it will go through the metadata to find the right RegionServer. Then, the RegionServer go through its managed regions to find the required data. A HFile is with multiple layers of index, bloom filters, and time range information to skip as much unnecessary data as possible. </p>
<h3><span id="data-write">Data Write</span></h3><p>Writing data into HBase has three steps. Firstly, the data is written to a WAL on HDFS. Secondly, the data is written to the MemStore. Finally, when the MemStore size reaches a threshold, the data is flushed into HDFS. In fact, once the data is recorded into the WAL, the write is already successful, though the data is invisible at that moment. If the RegionServer crashes before writing to the MemStore, the data can still be loaded into MemStore once the server recovers. </p>
<p>HBase does not support cross row transactions. However, it does support atomic intra-row operations, and we know that a row is actually a set of key-value pairs. Therefore, <strong>I think</strong> the set of key-value pairs are grouped into a transaction. </p>
<p>HBase provides strong consistency for read and write, which means every read gets exactly the same result. The result depends solely on the timestamp the request is received by HBase. In the HBase architecture, strong consistency is achieved based on HDFS. In other words, the HBase provides a consistent global view to the WAL for all RegionServers. </p>
<h3><span id="compaction-and-split">Compaction and Split</span></h3><p>HDFS is designed for batch process, and therefore, huge number of small files can cause a unacceptable memory footprint to the NameNode. There are two kinds of compaction, the minor compaction and the major compaction. A minor compaction collects a set of HFiles (belonging to the same column family) and merge them into one. A major compaction merge all HFiles belonging to the same column family into one. Since a major compaction consumes quite a lot of resources, it is recommended to be carried out carefully. From this point of view, HBase is not really suitable for use cases where data is manipulated frequently.</p>
<p>A region is a consecutive range of row keys. Once a region reaches a certain size (e.g., 1G), the region is split into two. This is to keep the size of a region from being too big. Big region is bad since <strong>region</strong> is the unit of parallal access in HBase. For instance, a mapreduce program treat each region a split. The region is split in an automatic way in default. But the user could also predefine the split boundaries when creating the table. </p>
<p>If the regions are split automatically, one need to be careful about the row key design. For instance, if the row key is mono-increasing numbers, the new arriving data will always be inserted to the newly split region, creating write hotspot. In generally, the row keys should be random enough to prevent both read hotspot and write hotspot. </p>
<p><br><br><br></p>
<p>Finally, I’d like to give my two cents on HBase:</p>
<ul>
<li>Better documentation: The current document is not well written. The text contains a lot of references to Jira issues and external articles which is really disrupting. As discussed above, HBase is really about <strong>tables</strong>, not some complicated maps. I understand the differences, but as a beginner, I prefer concepts closer to my existing mindset. </li>
<li>SQL interface: Providing a SQL-like interface is much more friendly than raw Java apis. Such an interface helps users to play with HBase much more easily. </li>
<li>Predefined partition: Predined partition feels more controllable than the automatic split. Though there is a way of defining the split boundaries which is still quite indirect. In practice, people usually know how to partition their data to achieve the best performance. This is the well adopted use case for RDBMs. </li>
<li>Local filesystem: HDFS is designed for batch access which HBase can be used for random access, even with frequent manipulations. Local filesystems might be a better choice. </li>
</ul>
<p>I also read about Kudu and MapR-DB. From the architecture point of view, they actually share a lot of design patterns. Only, Kudu and MapR-DB are built on the shoulder of HBase, so they can avoid pitfalls. Anyway, HBase is still a very good designed software which provide a very good study case. Thanks to the community and the contributors.</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/things-about-replication-in-elasticsearch/" class="prev">PREV</a><a href="/blog/invest/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="liqul.github.io/blog">Liqun Li</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>