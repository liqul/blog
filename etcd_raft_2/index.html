<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Raft协议实现学习之—etcd/raft库的使用 · Liqun's Homepage</title><meta name="description" content="Raft协议实现学习之—etcd/raft库的使用 - Liqun Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon2.jpeg"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="liqul.github.io/blog/atom.xml" title="Liqun's Homepage"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon2.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives" target="_self" class="nav-list-link">TAGS/ARCHIVE</a></li><li class="nav-list-item"><a href="/blog/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Raft协议实现学习之—etcd/raft库的使用</h1><div class="post-info">Sep 13, 2018</div><div class="post-content"><h1><span id="etcd中的raft协议实现">Etcd中的Raft协议实现</span></h1><p>Etcd里Raft协议的实现的在<a href="https://github.com/etcd-io/etcd/tree/master/raft" target="_blank" rel="noopener">这里</a>。etcd并不是Raft的唯一实现，事实上Raft协议有<a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">许多实现</a>，还有我简单尝试过的<a href="https://github.com/atomix/" target="_blank" rel="noopener">atomix</a>。选择etcd/raft是因为个人对etcd和go语言比较感兴趣，而且Raft论文里提到的实现方法恰好比较适合用go语言的goroutine来实现。</p>
<p>另外的一个原因正如etcd/raft在github上的readme所说：</p>
<blockquote>
<p>To keep the codebase small as well as provide flexibility, the library only implements the Raft algorithm; both network and disk IO are left to the user. Library users must implement their own transportation layer for message passing between Raft peers over the wire. Similarly, users must implement their own storage layer to persist the Raft log and state.</p>
</blockquote>
<a id="more"></a>
<p>etcd/raft采取了一种极简的实现方式，只有最核心的状态转移逻辑，不包含网络通信和磁盘读写，所以比较方便对照论文来梳理代码的实现。</p>
<h2><span id="etcdraft与用户系统的关系">Etcd/raft与用户系统的关系</span></h2><p>图1描述了基于etcd/raft完成一个分布式存储系统的一般结构。每个节点分为两部分，左边是用户需要自己实现的部分，右边代表etcd/raft库。在用户实现的逻辑中，首先是系统状态（State machine）。系统状态是与应用相关的，例如对于key-value store来说，它的系统状态可以描述为一个key-&gt;value的映射关系。正是由于系统状态是应用相关的，所以它必须由用户来实现，同时用户还必须实现系统状态的序列化和反序列化用于快照。</p>
<p><img src="/blog/assets/raft_modules.png" height="250"><br>图1. Raft实现模块关系示例实现的是一个key-value store，而其主要的结构体如下</p>
<p>需要特别注意系统状态并不是Raft协议的一部分。在基于Raft实现分布式系统的时候，可以采用这样的思路：先实现一个单机的功能齐备的系统，然后再利用Raft协议将它扩展到多节点模式。显然在这个单机系统中，系统状态及其维护都需要用户自己来实现，所以它并不是Raft协议的一部分。当然，并不是所有的单机系统都可以直接依赖Raft协议扩展到多个节点的，因为Raft协议本质上是多节点日志备份系统，这要求系统状态必须能描述为一组日志序列。</p>
<p>网络模块（Net）和持久化存储（Persistent store）分别提供节点间通信能力和持久化能力。Raft协议需要节点间通信来协同操作，而etcd/raft库本身不实现通信功能，而是每当节点间需要通信时把消息交给用户实现的网络模块发送到其它节点。同样，etcd/raft也不提供持久化能力，而节点需要将一些有用信息保存在持久化存储中，以便能在程序意外退出恢复时读取这些信息。</p>
<p>Etcd/raft库里与用户实现交互的逻辑由node完成（代码在node.go）。Node接收来自用户实现逻辑的大部分输入（除来自其它节点的网络消息外），此外还负责将raft状态机（代码在raft.go）输出的行动通过Ready结构发送到用户实现逻辑。用户逻辑与Raft之间共享一个存储结构Storage（代码在storage.go），对于两边都要读写的结构，需要锁来避免读写冲突。</p>
<h2><span id="一个可运行的示例">一个可运行的示例</span></h2><p>代码库里已经有一些关于如何使用的示例，但并没有一个完整的例子。而官方给出的<a href="https://github.com/etcd-io/etcd/tree/master/contrib/raftexample" target="_blank" rel="noopener">raftexample</a>例子由于依赖了etcd里的rafthttp和wal，引入了一些不利于梳理的内容。所幸这篇<a href="http://otm.github.io/2015/05/raft-a-first-implementation/" target="_blank" rel="noopener">blog</a>里作者提供了一个可以运行的最简单的示例，方便用作学习，对应的代码库在<a href="http://github.com/otm/raft-part-1" target="_blank" rel="noopener">这里</a>。由于作者实现的时间较早，代码引用的是旧的库地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"github.com/coreos/etcd/raft"</span></span><br><span class="line"><span class="string">"github.com/coreos/etcd/raft/raftpb"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改成下面</span></span><br><span class="line"></span><br><span class="line"><span class="string">"go.etcd.io/etcd/raft"</span></span><br><span class="line"><span class="string">"go.etcd.io/etcd/raft/raftpb"</span></span><br></pre></td></tr></table></figure>
<p>主体的数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	id     <span class="keyword">uint64</span>   <span class="comment">//raft节点的id</span></span><br><span class="line">	ctx    context.Context <span class="comment">//context</span></span><br><span class="line">	pstore <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//用来保存key-&gt;value的map</span></span><br><span class="line">	store  *raft.MemoryStorage <span class="comment">//raft需要的内存结构</span></span><br><span class="line">	cfg    *raft.Config <span class="comment">//raft需要的配置</span></span><br><span class="line">	raft   raft.Node    <span class="comment">//前面提到的node</span></span><br><span class="line">	ticker &lt;-<span class="keyword">chan</span> time.Time <span class="comment">//定时器，提供周期时钟源和超时触发能力</span></span><br><span class="line">	done   &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码示例里pstore实际上就是key-value store的存储结构。为了使用etcd/raft库，按照github里的<a href="https://github.com/etcd-io/etcd/tree/master/raft" target="_blank" rel="noopener">readme</a>所说，用户需要完成下面一些功能：</p>
<blockquote>
<p>First, read from the Node.Ready() channel and process the updates it contains. These steps may be performed in parallel, except as noted in step 2.</p>
<p>1.. 2.. 3.. 4..</p>
</blockquote>
<p>用户需要监听和处理Ready消息，上面引用里的4点内容较多在此省略。其中的要点是在执行任何操作之前都需要先持久化一些状态，这与<a href="/blog/etcd_raft_1">上一篇</a>文章中图2的工作原理是对应的。</p>
<blockquote>
<p>Second, all persisted log entries must be made available via an implementation of the Storage interface. The provided MemoryStorage type can be used for this (<strong>if repopulating its state upon a restart</strong>), or a custom disk-backed implementation can be supplied.</p>
</blockquote>
<p>用户需要实现Storage接口来存储必要的信息。MemoryStorage是库提供的一个基于内存的实现，本身并不能进行持久化。用户能自己增加逻辑来实现MemoryStorage的持久化。</p>
<blockquote>
<p>Third, after receiving a message from another node, pass it to Node.Step().</p>
</blockquote>
<p>如果接收到来自其它节点的消息，通过Step方法传递到raft的状态机。</p>
<blockquote>
<p>Finally, call Node.Tick() at regular intervals (probably via a time.Ticker). Raft has two important timeouts: heartbeat and the election timeout. However, internally to the raft package time is represented by an abstract “tick”.</p>
</blockquote>
<p>提供一个周期性的时钟定时触发Tick方法。</p>
<p>在示例实现里完成上述逻辑的代码如下（以First、Second、Third、Finally与上面的描述对应）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ready的处理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-n.ticker:    <span class="comment">// Finally</span></span><br><span class="line">			n.raft.Tick()</span><br><span class="line">		<span class="keyword">case</span> rd := &lt;-n.raft.Ready():    <span class="comment">//First</span></span><br><span class="line">			n.saveToStorage(rd.HardState, rd.Entries, rd.Snapshot) <span class="comment">//First.1</span></span><br><span class="line">			n.send(rd.Messages) <span class="comment">//First.2</span></span><br><span class="line">			<span class="keyword">if</span> !raft.IsEmptySnap(rd.Snapshot) &#123;</span><br><span class="line">				n.processSnapshot(rd.Snapshot) <span class="comment">//First.3</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, entry := <span class="keyword">range</span> rd.CommittedEntries &#123;</span><br><span class="line">                <span class="comment">// 对于key-value store这个应用，用户真正需要关心的只有下面这行</span></span><br><span class="line">				n.process(entry) <span class="comment">//First.3</span></span><br><span class="line">				<span class="keyword">if</span> entry.Type == raftpb.EntryConfChange &#123;</span><br><span class="line">					<span class="keyword">var</span> cc raftpb.ConfChange</span><br><span class="line">					cc.Unmarshal(entry.Data)</span><br><span class="line">					n.raft.ApplyConfChange(cc)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			n.raft.Advance() <span class="comment">//First.4</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-n.done:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Second. 作者并未实现Storage的持久化，所以这里只有MemoryStore的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">saveToStorage</span><span class="params">(hardState raftpb.HardState, entries []raftpb.Entry, snapshot raftpb.Snapshot)</span></span> &#123;</span><br><span class="line">	n.store.Append(entries)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !raft.IsEmptyHardState(hardState) &#123;</span><br><span class="line">		n.store.SetHardState(hardState)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !raft.IsEmptySnap(snapshot) &#123;</span><br><span class="line">		n.store.ApplySnapshot(snapshot)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者并未实现真正的网络模块，只是模拟了节点间的收发消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">receive</span><span class="params">(ctx context.Context, message raftpb.Message)</span></span> &#123;</span><br><span class="line">	n.raft.Step(ctx, message) <span class="comment">//Third</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Etcd/raft库的使用大致如代码示例里描述。当然，这里做了不少简化，例如：</p>
<ol>
<li>没有实现节点间的网络通信；</li>
<li>没有实现可持久化的存储；</li>
<li>没有实现快照的生成和处理逻辑；</li>
<li>用户Application是单线程的；</li>
</ol>
<p>这些将在后续的文章中逐步梳理和学习。</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/banks/" class="prev">上一篇</a><a href="/blog/etcd_raft_3/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="liqul.github.io/blog">Liqun Li</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>