<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Raft协议实现学习之——raft库的使用 · Liqun's Homepage</title><meta name="description" content="Raft协议实现学习之——raft库的使用 - Liqun Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon2.jpeg"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="liqul.github.io/blog/atom.xml" title="Liqun's Homepage"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon2.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives" target="_self" class="nav-list-link">TAGS/ARCHIVE</a></li><li class="nav-list-item"><a href="/blog/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Raft协议实现学习之——raft库的使用</h1><div class="post-info">Sep 13, 2018</div><div class="post-content"><p>etcd里的raft包的地址在<a href="https://github.com/etcd-io/etcd/tree/master/raft" target="_blank" rel="noopener">这里</a>。etcd并不是Raft的唯一实现，实际上有<a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">许多实现</a>，还有之前我简单尝试过的<a href="https://github.com/atomix/" target="_blank" rel="noopener">atomix</a>。选择etcd/raft是因为个人对etcd和go语言比较感兴趣，而且Raft论文里提到的实现方法恰好比较适合用go语言的goroutine来实现。</p>
<p>另外的一个原因正如github上的readme所说：</p>
<blockquote>
<p>To keep the codebase small as well as provide flexibility, the library only implements the Raft algorithm; both network and disk IO are left to the user. Library users must implement their own transportation layer for message passing between Raft peers over the wire. Similarly, users must implement their own storage layer to persist the Raft log and state.</p>
</blockquote>
<p>etcd/raft采取了一种极简的实现方式，只有最核心的状态转移逻辑，不包含网络通信和磁盘读写，所以比较方便对照论文来梳理代码的实现。代码库里已经有一些关于如何使用的示例，但并没有一个完整的例子。而官方给出的<a href="https://github.com/etcd-io/etcd/tree/master/contrib/raftexample" target="_blank" rel="noopener">raftexample</a>例子看起来似乎比较简单，但由于其依赖了etcd里的rafthttp和wal，引入了一些不必要的复杂处理逻辑。所幸这篇<a href="http://otm.github.io/2015/05/raft-a-first-implementation/" target="_blank" rel="noopener">blog</a>里作者提供了一个可以运行的最简单的示例，方便用作学习，对应的代码库在<a href="http://github.com/otm/raft-part-1" target="_blank" rel="noopener">这里</a>。由于作者实现的时间较早，代码引用的是旧的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;github.com/coreos/etcd/raft&quot;</span><br><span class="line">&quot;github.com/coreos/etcd/raft/raftpb&quot;</span><br></pre></td></tr></table></figure>
<p>要想正常执行，需要修改为新的地址，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;go.etcd.io/etcd/raft&quot;</span><br><span class="line">&quot;go.etcd.io/etcd/raft/raftpb&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/blog/assets/raft_modules.png"><br>图1. Raft实现模块关系（原图Figure 3.3）</p>
<p>图1描述了基于etcd/raft完成一个分布式存储系统的一般结构。每个节点分为两部分，左边（User implemented logic）是用户实现的逻辑，右边（Raft lib）代表etcd/raft库。在用户实现的逻辑中，首先是系统状态（State machine）。注意系统状态是与应用相关的，例如对于key-value store来说，它的系统状态表现为一个key-&gt;value的映射关系。正是由于系统状态是应用相关的所以它必须由用户来实现，同时用户还必须实现系统状态的序列化和反序列化用于提供快照。</p>
<p>网络模块（Net）和持久化存储（Persistent store）为应用分别提供节点间通信能力和持久化能力。Raft协议里需要节点间通信来协同完成操作，而etcd/raft库本身不实现通信功能，而是每当节点间需要通信时etcd/raft把消息交给用户实现的逻辑，由网络模块发送到其它节点。同理，etcd/raft也不提供持久化能力，而节点需要将一些有用信息保存在持久化存储中以便能在程序意外退出恢复时读取这些信息，所以用户需要在实现时提供这方面的能力。</p>
<p>etcd/raft库里与用户实现交互的逻辑由node和raft两部分完成。其中raft实现了Raft协议的状态机，状态机的输入是来自外部的消息，比如用户的写入请求或者来自其它节点的消息，状态机的输出包含要执行的一些操作，例如需要持久化的内容和要发送到其它节点的消息（这记录在Ready结构中）。在raft的代码里，状态机的驱动基于Step方法。Node接收来自用户实现逻辑的大部分输入（除来自其它节点的网络消息外），此外还负责将raft状态机输出的行动通过Ready结构发送到用户实现逻辑。</p>
<p>node和raft是在几个不同的线程上执行的？每个线程是一个actor</p>
<ol>
<li>node的run方法是一个独立线程；</li>
<li>net是一个独立的线程？<br>那么raft状态更新时如何保持的呢？需要结合论文里的实现逻辑梳理一下。</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/blog/etcd_raft_1/" class="prev">上一篇</a><a href="/blog/flink/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="liqul.github.io/blog">Liqun Li</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>