<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: Raft | Liqun&#39;s Homepage</title>
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/blog/">
  <link rel="alternate" href="/blog/atom.xml" title="Liqun's Homepage">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Liqun&#39;s Homepage">
<meta property="og:url" content="liqul.github.io/blog/tags/Raft/index.html">
<meta property="og:site_name" content="Liqun&#39;s Homepage">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liqun&#39;s Homepage">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/blog/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/blog/' >
				Liqun's Homepage
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/blog/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/blog/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-gallery' href='https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN'>
								Gallery
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/blog/about'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/blog/" class="nav-home nav">
				Home
			</a>
		
			<a href="/blog/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="https://photos.google.com/album/AF1QipNoqKYgspQo5O1YhlFXGCQ7p575KBH3Yxf8WHL4?hl=zh-CN" class="nav-gallery nav">
				Gallery
			</a>
		
			<a href="/blog/about" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
  <script>
    window.subData= { title:'Tag : Raft'}
  </script>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/etcd_raft_4/">
        Raft协议实现学习之—写入过程
      </a>
    </h2>
    
    <time>
      Nov 23, 2018
    </time>
		
    
    <div class='cats'>
        <a href="/blog/categories/Tech/">Tech</a>
    </div>

  </section>
  <section class="article typo">
	  <p>在上一篇文章重点梳理了选举的过程，而这一篇想着重梳理一下写入的过程。仍然沿着节点初始化的日志开始： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 阶段7：节点1成为leader后向其它节点广播MsgApp</span></span><br><span class="line">17:40:19 1-&gt;2 MsgApp Term:2 Log:1/3 Commit:3 Entries:[2/4 EntryNormal <span class="string">""</span>]</span><br><span class="line">17:40:19 3-&gt;1 MsgVoteResp Term:2 Log:0/0</span><br><span class="line">17:40:19 INFO: raft.node: 2 elected leader 1 at term 2</span><br><span class="line">17:40:19 1-&gt;3 MsgApp Term:2 Log:1/3 Commit:3 Entries:[2/4 EntryNormal <span class="string">""</span>]</span><br><span class="line">17:40:19 2-&gt;1 MsgAppResp Term:2 Log:0/4 <span class="comment"># 这里2汇报已经保存了新的entry</span></span><br><span class="line">17:40:19 INFO: raft.node: 3 elected leader 1 at term 2</span><br><span class="line">17:40:19 1-&gt;2 MsgApp Term:2 Log:2/4 Commit:4 <span class="comment"># 在这里commit从3变成4</span></span><br><span class="line">17:40:19 3-&gt;1 MsgAppResp Term:2 Log:0/4 </span><br><span class="line">17:40:19 node 1: processing entry: &#123;2 4 EntryNormal [] []&#125; <span class="comment"># 由于已经确认大部分节点都保存成功，可以apply到state machine</span></span><br><span class="line">17:40:19 1-&gt;3 MsgApp Term:2 Log:2/4 Commit:4</span><br><span class="line">17:40:19 2-&gt;1 MsgAppResp Term:2 Log:0/4</span><br><span class="line">17:40:19 node 2: processing entry: &#123;2 4 EntryNormal [] []&#125; <span class="comment"># 2在接收到来自1的MsgApp后得知commit=4，可以apply到本地的state machie</span></span><br><span class="line">17:40:19 3-&gt;1 MsgAppResp Term:2 Log:0/4</span><br><span class="line">17:40:19 node 3: processing entry: &#123;2 4 EntryNormal [] []&#125;</span><br></pre></td></tr></table></figure>
<p>在raft.becomeLeader方法的实现里，节点一旦选举成为leader会主动向自己的日志里写入一条空日志：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.appendEntry(pb.Entry&#123;Data: <span class="literal">nil</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>注意这条空日志并非前面提到过的<em>dummy entry</em>，而仅仅是内容为空的一条真实的日志，所以在上面程序输出的日志里，可以看到节点1将该日志复制到节点2和3的过程。当然，正常的写入流程的入口在node.Propose，其中会将用户给的数据组织成一个MsgProp然后发送到node的propc等待处理。</p>
<p>在Raft协议下，只有leader能处理来自client的写入请求，如果其它follower节点接收到请求也会转发给leader。leader和follower处理MsgProp的逻辑自然是不同的，分别在raft.stepLeader和raft.stepFollower里定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// leader的处理逻辑</span></span><br><span class="line">r.appendEntry(m.Entries...)</span><br><span class="line">r.bcastAppend()</span><br><span class="line"></span><br><span class="line"><span class="comment">// follower的处理逻辑</span></span><br><span class="line">r.handleAppendEntries(m)</span><br></pre></td></tr></table></figure>
<p>Leader的处理逻辑非常简单，将日志写入unstable，然后广播到所有followers。这里需要展开说明follower的处理情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// handleAppendEntries的处理逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常运行情况下m.Index应该等于r.raftLog.committed</span></span><br><span class="line"><span class="keyword">if</span> m.Index &lt; r.raftLog.committed &#123;</span><br><span class="line">    r.send(pb.Message&#123;To: m.From, Type: pb.MsgAppResp, Index: r.raftLog.committed&#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里几个参数的含义</span></span><br><span class="line"><span class="comment">// index是新entries的前一个entry的index</span></span><br><span class="line"><span class="comment">// logterm是新entries前一个entry的term</span></span><br><span class="line"><span class="comment">// commit是leader最大的committed entry的index</span></span><br><span class="line"><span class="comment">// entries是leader复制到follower的日志，但需要注意这些日志可能&lt;commit</span></span><br><span class="line"><span class="keyword">if</span> mlastIndex, ok := r.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...); ok &#123;</span><br><span class="line">    r.send(pb.Message&#123;To: m.From, Type: pb.MsgAppResp, Index: mlastIndex&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r.logger.Debugf(<span class="string">"%x [logterm: %d, index: %d] rejected msgApp [logterm: %d, index: %d] from %x"</span>,</span><br><span class="line">        r.id, r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(m.Index)), m.Index, m.LogTerm, m.Index, m.From)</span><br><span class="line">    r.send(pb.Message&#123;To: m.From, Type: pb.MsgAppResp, Index: m.Index, Reject: <span class="literal">true</span>, RejectHint: r.raftLog.lastIndex()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解这里逻辑的关键在于了解maybeAppend方法的含义。Follower在接收到一组来自leader的日志后需要判断这些日志是否能追加到自己本地的日志。MsgApp中的index和logterm分别是leader节点新复制的entries的前一条日志的index和term。可以再仔细阅读<a href="https://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener">论文</a>里Figure 3.1里AppendEntries RPC的结构说明。在正常运行状态下，这条日志应该是已经被commit的最后一条日志，从本文最开始的程序输出日志里就能看到：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17:40:19 1-&gt;2 MsgApp Term:2 Log:1/3 Commit:3 Entries:[2/4 EntryNormal <span class="string">""</span>]</span><br></pre></td></tr></table></figure>
<p>这条程序输出日志里打出了leader当前处于term2，而新entries的前一条日志是配置peer的日志，其term和index分别为1和3，leader最后commit的index也是3，最后新entry里的term和index分别为2和4。接收到这条记录的follower根据前一条日志的index来判断leader与自己的日志是否能匹配，即不存在中间漏掉日志的情况。判断的依据是matchTerm(index, logTerm)，即前一条日志是否已经在本地保存，如果没有说明中间存在漏洞。如果新来的日志可追加到本地，用户线程会根据接收到的Ready结构将日志持久化，然后给leader返回一条消息，如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17:40:19 2-&gt;1 MsgAppResp Term:2 Log:0/4</span><br></pre></td></tr></table></figure>
<p>这条消息里包含了写入日志的index，这里是4，通知leader index=4的日志已经在节点上成功复制。Leader节点在接收到MsgAppResp消息后，在raft.stepLeader下处理消息，处理逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在正常情况下，会进入如下判断</span></span><br><span class="line"><span class="keyword">if</span> pr.maybeUpdate(m.Index) &#123; <span class="comment">// 在这里面可能会更新peer的progress</span></span><br><span class="line">    <span class="comment">// peer的状态转移，参考raft/design.md文件说明</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> pr.State == ProgressStateProbe:</span><br><span class="line">        fmt.Printf(<span class="string">"%x become replicate\n"</span>, m.From)</span><br><span class="line">        pr.becomeReplicate()</span><br><span class="line">    <span class="keyword">case</span> pr.State == ProgressStateSnapshot &amp;&amp; pr.needSnapshotAbort():</span><br><span class="line">        r.logger.Debugf(<span class="string">"%x snapshot aborted, resumed sending replication messages to %x [%s]"</span>, r.id, m.From, pr)</span><br><span class="line">        pr.becomeProbe()</span><br><span class="line">    <span class="keyword">case</span> pr.State == ProgressStateReplicate:</span><br><span class="line">        pr.ins.freeTo(m.Index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r.maybeCommit() &#123; <span class="comment">// 这里判断是否有新的待commit的日志</span></span><br><span class="line">        r.bcastAppend()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> oldPaused &#123;</span><br><span class="line">        <span class="comment">// If we were paused before, this node may be missing the</span></span><br><span class="line">        <span class="comment">// latest commit index, so send it.</span></span><br><span class="line">        r.sendAppend(m.From)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可能继续向落后的节点发日志</span></span><br><span class="line">    <span class="keyword">for</span> r.maybeSendAppend(m.From, <span class="literal">false</span>) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码里的raft.maybeCommit的判断依据是大部分节点是否都已经复制了新的日志。如果判断成立，leader节点会调用raft.bcastAppend，从实现代码里可以看到即使没有新的日志，leader也会发送空信息来传达新的commit消息。所以，观察文章最前面的程序输出可以看到</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17:40:19 1-&gt;2 MsgApp Term:2 Log:2/4 Commit:4</span><br></pre></td></tr></table></figure>
<p>这里节点1向2发出的MsgApp消息里附带的commit已经由3变成4了。Leader节点一旦更新commit消息，在用户线程获得这个信息后（通过Ready结构）就可以把这条日志应用到状态机了，于是有</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17:40:19 node 1: processing entry: &#123;2 4 EntryNormal [] []&#125;</span><br></pre></td></tr></table></figure>
<p>至此，一条日志的写入过程结束。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/blog/tags/Raft/">Raft</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/multiraft/">
        从Raft到MultiRaft
      </a>
    </h2>
    
    <time>
      Nov 1, 2018
    </time>
		
    
    <div class='cats'>
        <a href="/blog/categories/Tech/">Tech</a>
    </div>

  </section>
  <section class="article typo">
	  <p>Raft是一种共识算法，在之前的文章里已经提到过。简而言之，每次集群处理一次请求，都需要经过集群中大部分节点协商。所以一个Raft集群的规模一般不会太大，否则协商的代价就会比较大。那么如果希望基于Raft实现一些规模比较大的服务该怎么扩展呢？</p>
<p>例如我们想做一个kv存储，那么一个简单的想法是把key分为多个range，然后不同的range由不同的Raft集群来控制。实际上，MultiRaft的思想就是这么简单…只是在实现上有一些细节需要考虑。如果希望更多理解MultiRaft的概念，可以读读这篇<a href="http://sergeiturukin.com/2017/06/09/multiraft.html" target="_blank" rel="noopener">文章</a>，还有<a href="https://www.cockroachlabs.com/blog/scaling-raft/" target="_blank" rel="noopener">这里</a>。从中可以发现，MultiRaft解决的两个核心问题分别是：</p>
<ul>
<li><strong>共享物理节点的问题</strong>：多个Raft集群实际上是共享物理节点的，所以需要小心组织每个节点上的数据；</li>
<li><strong>Heartbeat过多的问题</strong>：每个Raft集群逻辑节点需要处理Heartbeat消息，如果每个物理节点上都有多个Raft逻辑节点，那么开销会比较大，所以希望Heartbeat以物理节点为单位而不是逻辑节点。</li>
</ul>
<p>如果考虑跨Raft集群操作，实际上还有一个问题，就是如果一次操作跨不同的Raft集群怎么办？如果服务不需要提供事务那其实是没有问题的，但如果需要呢？现在使用MultiRaft的两个服务Cockroachdb和Tidb都有文档说明：</p>
<ul>
<li>Cockroachdb：看<a href="https://www.cockroachlabs.com/blog/how-cockroachdb-distributes-atomic-transactions/" target="_blank" rel="noopener">这里</a>和<a href="https://www.cockroachlabs.com/blog/serializable-lockless-distributed-isolation-cockroachdb/" target="_blank" rel="noopener">这里</a>；</li>
<li>Tidb：看<a href="https://pingcap.com/blog-cn/percolator-and-txn/" target="_blank" rel="noopener">这里</a>。</li>
</ul>
<p>Cockroachdb的思路比较容易理解，也跟我想的差不多，而Tidb的则没有看明白，尤其是关于锁的问题。</p>
<p>下面按照我自己的理解来说明。首先，数据需要以MVCC方式存储，即每个kv保存多个版本，例如：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>commit</th>
<th>state</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
<td>1</td>
<td>stable</td>
</tr>
<tr>
<td>a</td>
<td>2</td>
<td>2</td>
<td>unstable</td>
</tr>
<tr>
<td>b</td>
<td>1</td>
<td>1</td>
<td>stable</td>
</tr>
</tbody>
</table>
<p>每个kv除了key和value额外保留两个字段，分别是commit和state。在这里stable代表一次事务已经完成，可以被外界读取的情况；反之，如果是unstable，表示事务没有完结，对外不可见。</p>
<p>在一次写入的时候，如果所涉及的数据都分布在一个Raft集群内，那么是不需要考虑事务的，因为这些变更可以记做一条Raft日志，从而达到事务的效果。只有跨多个Raft集群时才需要用Two-phase commit (2PC)来达到整体的事务效果。</p>
<p>在2PC的第一个阶段，每个Raft集群完成写入后，内部节点的状态（即一个kv map）对应的state都是unstable，表示这时候只是单个Raft完成写入，还需要等待2PC coordinator确定是否所有Raft集群都完成写入。数据里的commit是事务的编号，这可以由一个独立的服务来产生事务编号，保证commit单调递增。当所有Raft集群都写入成功，2PC进入第二个阶段，由coordinator向所有集群通告已经成功的commit号，接收到该信息后各个Raft集群将commit对应数据的state由unstable改变成stable，一次事务完成。</p>
<p>总的来说，MultiRaft是对Raft的一种扩展。但是，MultiRaft还不方便简单抽取出来作为一种可供其它应用直接使用的库，与业务逻辑的关联性比较强。不过，有了Cockroachdb和Tidb的实际应用，对其它类似的存储结构的扩展是很好的参考。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/blog/tags/Raft/">Raft</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/etcd_raft_1/">
        Raft协议实现学习之—概览
      </a>
    </h2>
    
    <time>
      Sep 13, 2018
    </time>
		
    
    <div class='cats'>
        <a href="/blog/categories/Tech/">Tech</a>
    </div>

  </section>
  <section class="article typo">
	  <h1 id="Raft协议概览"><a href="#Raft协议概览" class="headerlink" title="Raft协议概览"></a>Raft协议概览</h1><h2 id="Raft是什么？"><a href="#Raft是什么？" class="headerlink" title="Raft是什么？"></a>Raft是什么？</h2><p>Raft是一种共识协议。与Raft完成相同任务的系统有Chubby和Zookeeper，以及一些系统内置的完成类似功能的组件，例如Elasticsearch里的Zen-Discovery。简而言之，共识协议的目的是让一组节点在响应外界输入时能表现的像一个节点一样。共识系统往往应用于有主备结构的存储系统中，如果缺少这种协议，就无法避免数据<a href="http://www.bailis.org/blog/when-does-consistency-require-coordination/" target="_blank" rel="noopener">错误</a>。</p>

    
	  <div class="readmore">
      <a href="/blog/etcd_raft_1/">Read More</a>
    </div>
    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/blog/tags/Raft/">Raft</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/etcd_raft_2/">
        Raft协议实现学习之—etcd/raft库的使用
      </a>
    </h2>
    
    <time>
      Sep 13, 2018
    </time>
		
    
    <div class='cats'>
        <a href="/blog/categories/Tech/">Tech</a>
    </div>

  </section>
  <section class="article typo">
	  <h1 id="Etcd中的Raft协议实现"><a href="#Etcd中的Raft协议实现" class="headerlink" title="Etcd中的Raft协议实现"></a>Etcd中的Raft协议实现</h1><p>Etcd里Raft协议的实现的在<a href="https://github.com/etcd-io/etcd/tree/master/raft" target="_blank" rel="noopener">这里</a>。etcd并不是Raft的唯一实现，事实上Raft协议有<a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">许多实现</a>，还有我简单尝试过的<a href="https://github.com/atomix/" target="_blank" rel="noopener">atomix</a>。选择etcd/raft是因为个人对etcd和go语言比较感兴趣，而且Raft论文里提到的实现方法恰好比较适合用go语言的goroutine来实现。</p>
<p>另外的一个原因正如etcd/raft在github上的readme所说：</p>
<blockquote>
<p>To keep the codebase small as well as provide flexibility, the library only implements the Raft algorithm; both network and disk IO are left to the user. Library users must implement their own transportation layer for message passing between Raft peers over the wire. Similarly, users must implement their own storage layer to persist the Raft log and state.</p>
</blockquote>

    
	  <div class="readmore">
      <a href="/blog/etcd_raft_2/">Read More</a>
    </div>
    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/blog/tags/Raft/">Raft</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/etcd_raft_3/">
        Raft协议实现学习之—初始化和Leader Election过程
      </a>
    </h2>
    
    <time>
      Sep 13, 2018
    </time>
		
    
    <div class='cats'>
        <a href="/blog/categories/Tech/">Tech</a>
    </div>

  </section>
  <section class="article typo">
	  <h2><span id="实验代码和输出">实验代码和输出</span></h2><p>实验代码是基于作者<a href="http://github.com/otm/raft-part-1" target="_blank" rel="noopener">原来的代码</a>稍微修改而来，main函数如下所示:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	nodes = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// start a small cluster</span></span><br><span class="line">	nodes[<span class="number">1</span>] = newNode(<span class="number">1</span>, []raft.Peer&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">	<span class="keyword">go</span> nodes[<span class="number">1</span>].run()</span><br><span class="line"></span><br><span class="line">	nodes[<span class="number">2</span>] = newNode(<span class="number">2</span>, []raft.Peer&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">	<span class="keyword">go</span> nodes[<span class="number">2</span>].run()</span><br><span class="line"></span><br><span class="line">	nodes[<span class="number">3</span>] = newNode(<span class="number">3</span>, []raft.Peer&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">	<span class="keyword">go</span> nodes[<span class="number">3</span>].run()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for leader election</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的这段代码里首先创建了3个节点，然后程序进入休眠等待节点竞争leader。程序的输出如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阶段1：节点初始化数据结构</span></span><br><span class="line">17:40:03 INFO: 1 became follower at term 0</span><br><span class="line">17:40:03 INFO: newRaft 1 [peers: [], term: 0, commit: 0, applied: 0, lastindex: 0, lastterm: 0]</span><br><span class="line">17:40:03 INFO: 1 became follower at term 1</span><br><span class="line">17:40:03 INFO: 2 became follower at term 0</span><br><span class="line">17:40:03 INFO: newRaft 2 [peers: [], term: 0, commit: 0, applied: 0, lastindex: 0, lastterm: 0]</span><br><span class="line">17:40:03 INFO: 2 became follower at term 1</span><br><span class="line">17:40:03 INFO: 3 became follower at term 0</span><br><span class="line">17:40:03 INFO: newRaft 3 [peers: [], term: 0, commit: 0, applied: 0, lastindex: 0, lastterm: 0]</span><br><span class="line">17:40:03 INFO: 3 became follower at term 1</span><br><span class="line"><span class="comment"># 阶段2：节点处理配置的peer列表</span></span><br><span class="line">17:40:03 node 1: processing entry: &#123;1 1 EntryConfChange [8 0 16 0 24 1] []&#125;</span><br><span class="line">17:40:03 node 1: processing entry: &#123;1 2 EntryConfChange [8 0 16 0 24 2] []&#125;</span><br><span class="line">17:40:03 node 1: processing entry: &#123;1 3 EntryConfChange [8 0 16 0 24 3] []&#125;</span><br><span class="line">17:40:03 node 2: processing entry: &#123;1 1 EntryConfChange [8 0 16 0 24 1] []&#125;</span><br><span class="line">17:40:03 node 3: processing entry: &#123;1 1 EntryConfChange [8 0 16 0 24 1] []&#125;</span><br><span class="line">17:40:03 node 3: processing entry: &#123;1 2 EntryConfChange [8 0 16 0 24 2] []&#125;</span><br><span class="line">17:40:03 node 3: processing entry: &#123;1 3 EntryConfChange [8 0 16 0 24 3] []&#125;</span><br><span class="line">17:40:03 node 2: processing entry: &#123;1 2 EntryConfChange [8 0 16 0 24 2] []&#125;</span><br><span class="line">17:40:03 node 2: processing entry: &#123;1 3 EntryConfChange [8 0 16 0 24 3] []&#125;</span><br><span class="line"><span class="comment"># 阶段3：节点1开启新一轮leader election</span></span><br><span class="line">17:40:19 INFO: 1 is starting a new election at term 1</span><br><span class="line">17:40:19 INFO: 1 became candidate at term 2</span><br><span class="line"><span class="comment"># 阶段4：节点1向节点2和3发送MsgVote</span></span><br><span class="line">17:40:19 INFO: 1 received MsgVoteResp from 1 at term 2</span><br><span class="line">17:40:19 INFO: 1 [logterm: 1, index: 3] sent MsgVote request to 2 at term 2</span><br><span class="line">17:40:19 INFO: 1 [logterm: 1, index: 3] sent MsgVote request to 3 at term 2</span><br><span class="line"><span class="comment"># 阶段5：节点2和3处理来自节点1的MsgVote请求</span></span><br><span class="line">17:40:19 1-&gt;2 MsgVote Term:2 Log:1/3</span><br><span class="line">17:40:19 1-&gt;3 MsgVote Term:2 Log:1/3</span><br><span class="line">17:40:19 INFO: 2 [term: 1] received a MsgVote message with higher term from 1 [term: 2]</span><br><span class="line">17:40:19 INFO: 2 became follower at term 2</span><br><span class="line">17:40:19 INFO: 2 [logterm: 1, index: 3, vote: 0] cast MsgVote <span class="keyword">for</span> 1 [logterm: 1, index: 3] at term 2</span><br><span class="line">17:40:19 2-&gt;1 MsgVoteResp Term:2 Log:0/0</span><br><span class="line">17:40:19 INFO: 1 received MsgVoteResp from 2 at term 2</span><br><span class="line"><span class="comment"># 阶段6：节点1成功成为leader</span></span><br><span class="line">17:40:19 INFO: 1 [quorum:2] has received 2 MsgVoteResp votes and 0 vote rejections</span><br><span class="line">17:40:19 INFO: 3 [term: 1] received a MsgVote message with higher term from 1 [term: 2]</span><br><span class="line">17:40:19 INFO: 1 became leader at term 2</span><br><span class="line">17:40:19 INFO: 3 became follower at term 2</span><br><span class="line">17:40:19 INFO: raft.node: 1 elected leader 1 at term 2</span><br><span class="line">17:40:19 INFO: 3 [logterm: 1, index: 3, vote: 0] cast MsgVote <span class="keyword">for</span> 1 [logterm: 1, index: 3] at term 2</span><br><span class="line"><span class="comment"># 阶段7：节点1成为leader后向其它节点广播MsgApp</span></span><br><span class="line">17:40:19 1-&gt;2 MsgApp Term:2 Log:1/3 Commit:3 Entries:[2/4 EntryNormal <span class="string">""</span>]</span><br><span class="line">17:40:19 3-&gt;1 MsgVoteResp Term:2 Log:0/0</span><br><span class="line">17:40:19 INFO: raft.node: 2 elected leader 1 at term 2</span><br><span class="line">17:40:19 1-&gt;3 MsgApp Term:2 Log:1/3 Commit:3 Entries:[2/4 EntryNormal <span class="string">""</span>]</span><br><span class="line">17:40:19 2-&gt;1 MsgAppResp Term:2 Log:0/4 <span class="comment"># 这里2汇报已经保存了新的entry</span></span><br><span class="line">17:40:19 INFO: raft.node: 3 elected leader 1 at term 2</span><br><span class="line">17:40:19 1-&gt;2 MsgApp Term:2 Log:2/4 Commit:4 <span class="comment"># 在这里commit从3变成4</span></span><br><span class="line">17:40:19 3-&gt;1 MsgAppResp Term:2 Log:0/4 </span><br><span class="line">17:40:19 node 1: processing entry: &#123;2 4 EntryNormal [] []&#125; <span class="comment"># 由于已经确认大部分节点都保存成功，可以apply到state machine</span></span><br><span class="line">17:40:19 1-&gt;3 MsgApp Term:2 Log:2/4 Commit:4</span><br><span class="line">17:40:19 2-&gt;1 MsgAppResp Term:2 Log:0/4</span><br><span class="line">17:40:19 node 2: processing entry: &#123;2 4 EntryNormal [] []&#125; <span class="comment"># 2在接收到来自1的MsgApp后得知commit=4，可以apply到本地的state machie</span></span><br><span class="line">17:40:19 3-&gt;1 MsgAppResp Term:2 Log:0/4</span><br><span class="line">17:40:19 node 3: processing entry: &#123;2 4 EntryNormal [] []&#125;</span><br><span class="line"><span class="comment"># 阶段8：进入心跳阶段</span></span><br><span class="line">17:40:20 1-&gt;2 MsgHeartbeat Term:2 Log:0/0 Commit:4</span><br><span class="line">17:40:20 1-&gt;3 MsgHeartbeat Term:2 Log:0/0 Commit:4</span><br><span class="line">17:40:20 2-&gt;1 MsgHeartbeatResp Term:2 Log:0/0</span><br><span class="line">17:40:20 3-&gt;1 MsgHeartbeatResp Term:2 Log:0/0</span><br><span class="line">17:40:21 1-&gt;2 MsgHeartbeat Term:2 Log:0/0 Commit:4</span><br><span class="line">17:40:21 1-&gt;3 MsgHeartbeat Term:2 Log:0/0 Commit:4</span><br><span class="line">17:40:21 2-&gt;1 MsgHeartbeatResp Term:2 Log:0/0</span><br><span class="line">17:40:21 3-&gt;1 MsgHeartbeatResp Term:2 Log:0/0</span><br></pre></td></tr></table></figure>
<h2><span id="节点的基本数据结构">节点的基本数据结构</span></h2><p>正常情况下，初始化节点的代码在/raft/node.go里的StartNode方法。每个Node结构都关联到一个raft结构（定义在/raft/raft.go里）。其中Node负责与应用线程交互，而raft负责实现Raft协议的状态机，根据Node的输入raft产生相应的输出。</p>
<h3><span id="softstate和hardstate">SoftState和HardState</span></h3><p>在实现里有两种状态，稍微说明一下。在Raft作者的<a href="https://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener">论文</a>里，图3.1里列举了不同节点需要保存的状态，分为Persistent state和Volatile state。其中Persistent state包括currentTerm、votedFor和log[]，这三个数据的前两个定义在HardState结构里（/raft/raftpb/raft.pb.go），而log[]则在Storage里维护，例如MemoryStorage里的ents数组。与论文不同的地方，在HardState里还包含了Commit，即论文图3.1里Volatile state里的commitIndex（todo:理解这里区别的含义）。SoftState与图中的Volatile state没有直接关系，其中包含了节点当前leader的id，以及节点当前的状态（leader还是follower等）。</p>
<p>此外，观察etcd/raft的实现发现，在MemoryStorage的初始化过程中，会向ents里写入一个<em>dummy entry</em>；而在ApplySnapshot方法里会在压缩完历史的entry之后初始化ents时写入一个特殊的entry，仅包含snapshot中最后一个entry的term和index。因此，在任何时刻在ents数组中的第一个元素都不是真正的entry，在一些处理过程中需要注意这一点（例如MemoryStorage的FirstIndex接口实现）。</p>
<h3><span id="log的状态">Log的状态</span></h3><p>完整的管理entry（或称为log）的结构是raftLog（参考/raft/log.go）。其中主要的属性，</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unstable</td>
<td>记录所有收到但未成功复制到多数节点的日志，或尚未持久化的snapshot</td>
</tr>
<tr>
<td>committed</td>
<td>记录最大的已经被复制到多数节点的日志</td>
</tr>
<tr>
<td>applied</td>
<td>记录最大的已经被应用到状态机的日志</td>
</tr>
<tr>
<td>storage</td>
<td>记录已经持久化的日志，和最新的已经持久化的snapshot</td>
</tr>
</tbody>
</table>
<p>每个entry都应该按照顺序先是unstable，然后是committed，最后才是applied，这个顺序不能乱。unstable和storage分别记录了未持久化和已持久化的entry和snapshot。</p>
<h3><span id="peer列表">Peer列表</span></h3><p>Raft论文图3.1里，作为leader，还需要维护两个状态，即nextIndex[]和matchIndex[]。这两者的实现在/raft/progress.go里，其中的主要结构体Progress用于记录每个follower节点的进度。其中match和next的定义分别是：</p>
<ul>
<li>match：follower与leader间一致的最大的entry</li>
<li>next：leader下一个要复制到follower的entry</li>
</ul>
<p>代码库里专门有一个markdown文件来说明这些概念及其使用方式，在/raft/design.md。正常情况下，follower与leader的entry列表应该完全一样，但由于leader处理新接收到的entry；节点故障而导致新一轮选举；有新节点加入，follower与leader之间出现不一致。这时候leader首先要了解follower的进度与自己进度的区别，此时的follower处于probe状态。如果follower接收并成功复制来自leader的entry，那么follower进入replicate状态，leader一次可以发出大于一条entry以提高传输效率。</p>
<p>在未了解follower的进度时，leader的行为是设置match=0和next=lastIndex+1。这样做是假定follower已经复制了所有leader上的日志。下一次leader向其follower发起复制的时候，如果follower实际上落后一些，会reject新的日志，并会告知leader自己的当前状态，leader根据情况再协调后续的发送。这里的逻辑参考/raft/raft.go里的handleAppendEntries实现。</p>
<p>snapshot相关的过程留在后续分析。</p>
<h2><span id="增加peer节点">增加peer节点</span></h2><p>通常情况下在集群初始化时都会有多个节点，例如在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodes[<span class="number">1</span>] = newNode(<span class="number">1</span>, []raft.Peer&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>里在初始化节点1时就向它的构造方法里传入了三个节点ID。考察StartNode方法（/raft/node.go）可以清楚的看到，对每一个ID，当前都会往日志里主动增加一条ConfChangeAddNode消息。这其实是在模仿节点从网络接收到了增加节点的配置消息，这两者后续的处理逻辑是相同的。</p>
<p>Raft节点的线程逻辑在node.run方法里。Run的逻辑大致是：</p>
<ol>
<li>等待新的触发事件，例如接收到来自用户线程的写入请求；接收到来自网络的消息等等。</li>
<li>被触发后经过raft.Step来驱动Raft协议状态机，输出一些变化（由containsUpdates来检验）。这些变化可能包括节点状态变化，或者有新的消息要发送，或者有新的log要持久化等等。</li>
<li>如果有新的变化，那么组织一个Ready结构发送给用户线程，具体的网络和持久化操作都在用户线程完成。</li>
</ol>
<p>回到增加peer节点的情况，以advancec和readyc（run方法开头定义的临时变量）为线索来整理执行的流程。下图梳理了用户线程（app.run）和Raft线程（node.run）的交互逻辑：</p>
<p><img src="/blog/assets/add_peer.png"></p>
<center>图1. 节点初始化peer列表过程中用户线程和Raft线程之间的交互过程</center>

<p>由于在初始化时已经指定了3个节点，所以在检查containsUpdates时会发现更新。后续的过程就如图1所示，在交互过程中用到的一系列channel也标记在图中的箭头上。在初始化的过程中，节点均处于follower角色，所以增加节点仅仅是向peer列表里增加了一些记录。</p>
<h2><span id="成为leader的过程">成为Leader的过程</span></h2><p>在完成初始化之后，选举的过程是由超时来触发的。注意在初始化过程中，会执行becomeFollower（raft.go)将节点角色设置为follower。其中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.step = stepFollower <span class="comment">// 设置step逻辑</span></span><br><span class="line">r.reset(term)</span><br><span class="line">r.tick = r.tickElection <span class="comment">// 设置tick逻辑</span></span><br><span class="line">r.lead = lead</span><br><span class="line">r.state = StateFollower</span><br><span class="line">r.logger.Infof(<span class="string">"%x became follower at term %d"</span>, r.id, r.Term)</span><br></pre></td></tr></table></figure>
<p>包含设置step和tick逻辑的代码。在follower角色下，节点的超时行为是触发下一次选举；对应的，如果处于leader角色中，超时则是触发发送心跳消息。如果follower节点超时了，会给自己“发送”一个MsgHup消息，进而开始竞选leader。在竞选前的一些逻辑包括：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// campaign</span></span><br><span class="line">r.becomeCandidate()</span><br><span class="line">voteMsg = pb.MsgVote</span><br><span class="line">term = r.Term</span><br><span class="line"></span><br><span class="line"><span class="comment">// becomCandidate</span></span><br><span class="line">r.step = stepCandidate  <span class="comment">// 更改step逻辑</span></span><br><span class="line">r.reset(r.Term + <span class="number">1</span>)		<span class="comment">// 增加term</span></span><br><span class="line">r.tick = r.tickElection <span class="comment">// 处于candidate角色下节点超时触发下一轮选举</span></span><br><span class="line">r.Vote = r.id</span><br><span class="line">r.state = StateCandidate</span><br></pre></td></tr></table></figure>
<p>随后，竞选节点需要邀请其它节点提名自己。当然，如果集群是只包含一个节点这种特殊情况，则不需要经过其它节点提名的过程而直接当选。发送邀请的过程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> id := <span class="keyword">range</span> r.prs &#123;</span><br><span class="line">	<span class="keyword">if</span> id == r.id &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里可以与论文原图Figure 3.1里的RequestVote RPC对照理解</span></span><br><span class="line">	<span class="comment">// Term: candidate的term</span></span><br><span class="line">	<span class="comment">// To: candidate的id</span></span><br><span class="line">	<span class="comment">// Type: MsgVote</span></span><br><span class="line">	<span class="comment">// Index: candidate最新一条log的index，这里的log包含unstable</span></span><br><span class="line">	<span class="comment">// LogTerm: candidate最新一条log的term，这里的log包含unstable</span></span><br><span class="line">	r.send(pb.Message&#123;Term: term, To: id, Type: voteMsg, Index: r.raftLog.lastIndex(), LogTerm: r.raftLog.lastTerm(), Context: ctx&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener">论文</a>3.6章讨论的是在选举过程中的安全问题，即如何避免一个log落后的节点竞选成为leader。作者提出了一个需要保证的性质——Leader Completeness Property，说明如下：</p>
<div class="tip"><br>If a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms.<br></div>

<p>也就是一旦一条log确认被committed了，那么它一定要出现在下一个竞选成功的leader的日志里。这句话有两个问题：</p>
<h3><span id="如何判断一条log已经committed">如何判断一条log已经committed？</span></h3><p>按照定义，committed的标准是在多数节点上复制成功。具体考虑一次写入操作，首先log通过网络复制到多数节点的日志；然后leader获得复制情况，确定完成复制后在本地commit日志；最后通过心跳消息通知其它节点commitment信息，接收到消息的其它节点在本地commit日志。从这个过程来看，leader和follower角色下的节点对同一条log是否已经被commit的认识时机是不同的，leader先于follower知晓该信息。如果leader已经知晓commitment但没来得及通知其它节点就掉线了，那么这条本来已经被commit的消息会怎么样呢？按照论文的讨论，由于其它节点并不知晓这条log已经被commit，所以如果一个没有包含这条log的节点当选为leader，那么这条本已经复制到多数节点的消息将被抹掉。所以，个人认为更为精确的说法是</p>
<div class="tip"><br>一条log被commit，意味着它已经被复制到多数节点，并且多数节点已经知晓来自leader的commit的信息。<br></div>

<h3><span id="如何保证committed的log出现在后续竞选成功的leader">如何保证committed的log出现在后续竞选成功的leader？</span></h3><p>按照上一个问题的逻辑，在MsgVote RPC里每个节点都应该包含自己已知的committed的日志的term和index，这样大家比较以后就能自然得出谁更加“up-to-date”一些。但是对比代码的实现细节，与论文的描述有所区别。在上面的代码片段里，raftLog.lastIndex和raftLog.lastTerm对应了index和term的值。而观察它们的实现，这里的“最后一条log”实际上包含了unstable结构里的数据，也就是包含没有被commit的日志。这样修改有什么影响呢？个人觉得这不会打破Leader Completeness Property，但会影响协议的行为。考虑一条日志被复制到多数节点但没有完成commitment，这时如果leader掉线，下一个被选举的leader一定包含这条尚未被commit的日志，因为那些尚未复制这条日志的节点无法得到足够多节点的支持。</p>
<p>节点接收到MsgVote后判断candidate的日志是否足够新的逻辑在raftLog.isUpToDate。</p>
<h3><span id="如何防止节点扰乱选举">如何防止节点扰乱选举</span></h3><p>解决了这两个问题，还有可能出现一种异常情况：如果一个失联节点不断增大自己的term，然后邀请其它正常工作状态下的节点参与选举，会扰乱集群的执行秩序。这个问题在论文的4.2.3章节讨论。</p>
<p>基本思想是如果一个节点能够接收到来自其leader的心跳，那么它不会参与选举。这个逻辑的实现可以查看raft.go下的inLease变量定义。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/blog/tags/Raft/">Raft</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/the-raft-consensus-algorithm/">
        Notes on The Raft Consensus Algorithm
      </a>
    </h2>
    
    <time>
      Mar 31, 2017
    </time>
		
    
    <div class='cats'>
        <a href="/blog/categories/Tech/">Tech</a>
    </div>

  </section>
  <section class="article typo">
	  <p>What’s consensus?</p>
<blockquote>
<p>It allows a collection of machines to work as a coherent group that can survive the failures of some of its members.</p>
</blockquote>
<p>It means not only a group of machines reach a final decision for a request, but also the state machine is replicated across these machines, so that some failures do not affect the functioning. Raft is a consensus algorithm seeking to be correct, implementable, and understandable. </p>
<p>The <a href="https://ramcloud.stanford.edu/~ongaro/thesis.pdf" target="_blank" rel="noopener">thesis</a> is very well written. It is much more comprehensive compared to the NSDI paper. Implementing Raft based on the thesis shouldn’t be too difficult (of course, also not trivial). The author also built a <a href="https://raft.github.io/" target="_blank" rel="noopener">website</a> putting all kinds of helping things there. I read the paper and decide to take some notes here.</p>
<p><img src="/blog/assets/state.png" width="800"></p>
<p>There are two key parts sitting in the core of the algorithm:</p>
<p><strong>Leader election</strong></p>
<p>The election is triggered by a timeout. If a server failed to detect heartbeats from the current leader, it start a new <em>term</em> of election. During the term, it broadcast requests to collect votes from other servers. If equal or more than majority of servers reply with a vote, the server becomes the leader of this term. The “term” here is a monotonically increasing logic time. From the perspective of a server receiving the vote request, it decides whether to give the vote based on a few considerations. First of all, if the sender even falls behind the receiver in terms of log index, the receiver should not vote for it. Also, if the receiver can still hear the heartbeats from current leader, it should not vote too. In this case, the requester might be a <em>disruptive server</em>. In other cases, the receiver should vote for the sender. </p>
<p><img src="/blog/assets/leader election.png" width="800"></p>
<p><strong>Log replication</strong></p>
<p>Once a server becomes the leader, it’s mission is simply replicate it’s log to every other follower. The replication means make the log of a follower <em>exactly</em> the same as the leader. For each pair of leader and follower, the leader first identify the highest index where they reach an agreement. Starting from there, the leader overwrite its log to the follower. The leader handles all requests from clients. Once it receives a new request, it first put the request into its own log. Then, it replicate the request to all followers. If equal or more than majority followers (including the leader itself) answer the replication request with success, the leader apply the request into its state machine (this is called commit). The leader put the new log index into its heartbeats, so followers know if the request has been committed, after which each follower commit the request too.</p>
<p><img src="/blog/assets/log replication.png" width="800"></p>
<p>More formal introduction of the core Raft could be found in Fig. 3.1 in the thesis paper. There are also a few extensions to make the algorithm practical to be used in production systems, such as the group management. I also found Fig. 10.1 a very good reference of architecture. </p>
<p>There are quite a lot of implementations of Raft, which could be found <a href="https://raft.github.io/" target="_blank" rel="noopener">here</a>. I also find a project named Copycat, with code <a href="https://github.com/atomix/copycat" target="_blank" rel="noopener">here</a> and document <a href="http://atomix.io/copycat/" target="_blank" rel="noopener">here</a>. Copycat is a full featured implementation of Raft in java. Building your own application based on Copycat shouldn’t be too difficult. They provide an example of implementing a KV store based on Copycat in their source code <a href="https://github.com/atomix/copycat/tree/master/examples" target="_blank" rel="noopener">here</a>, which is used as the “<a href="http://atomix.io/copycat/docs/getting-started/" target="_blank" rel="noopener">Get Started</a>“ tutorial. Another very important reason, why I think Copycat a good reference, is that it emphases the abstraction of state machine, client, server, and operations. Therefore, going through it’s document enhanced my understanding of Raft. </p>
<p>If you don’t want to build your own Raft, may be Copycat is worthwhile a try, though I haven’t any real experience beyond a toy project.</p>
<p>The annotated thesis could be found <a href="/blog/assets/raft-thesis.pdf">here</a>.</p>
<p><strong>A go-through case for understanding</strong></p>
<p>A typical request handling process is as follows:</p>
<ol>
<li>The client sends a request to the cluster;</li>
<li>The leader handles the request by putting it to a WAL;</li>
<li>The leader sends the request to all followers;</li>
<li>Each follower puts the received request to its WAL, and responds to the leader;</li>
<li>Once the leader has heard a majority number of responses from its followers, the leader commit the request by applying the WAL to its state machine;</li>
<li>The leader inform the client that the request has been handled properly, and then, put the index of the request into its heartbeat to let all followers know the status of each request;</li>
<li>Once the follower knows that the request has been committed by the leader, the follower commit the request too by applying it to its own state machine. </li>
</ol>
<p>There are a few key points to understand in the process above:</p>
<p>1.Does the client always know if its request has been handled properly?</p>
<p>No. If the leader commits the request and then crashes, the client will not know if the request has been actually successfully handled. In some cases, the client will resend the request which may lead to duplicated data. It leaves for the client to avoid such kind of duplication. </p>
<p>2.How about the leader crashes before inform its followers that the request has been committed?</p>
<p>If the leader crashes, a follower will be elected to be the next leader. The follower must have the latest state according to the mechanism of Raft. Therefore, the next leader definitely has the WAL for the request, and the request has definitely been replicated across a majority number of hosts. Therefore, it is safe to replicate its state to all followers. </p>
<p>3.Key feature of a consensus algorithm (or strong consistency)?</p>
<p>Under normal situations, if there’s a state change, the key step changing the state should be always handled by a certain node. The state changing should be replicated to a majority number of followers before informing the requester a success. Each read request goes to that certain node as well. Once there’s node failures or networking partitions, the service stop working until returning to the normal situation again.</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/blog/tags/Raft/">Raft</a>
      
        <a href="/blog/tags/Consensus/">Consensus</a>
      
        <a href="/blog/tags/Copycat/">Copycat</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
</section>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<div class='header'>Liqun Li</div>
<div class='content'>
<div class='desc'>Tempora mutantur, nos et mutamur in illis ...</div>
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://ccoooss.com">
            <div class='name'>ClassicOldSong</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://frantic1048.logdown.com/">
            <div class='name'>Frantic1048</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://hclmaster.github.io/">
            <div class='name'>Hclmaster</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://whst.github.io/">
            <div class='name'>WANG Hsü-Tung</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/blog/categories/Book-Reading/"><div class='name'>Book Reading</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/blog/categories/Finance/"><div class='name'>Finance</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/blog/categories/Photography/"><div class='name'>Photography</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/blog/categories/Reading/"><div class='name'>Reading</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/blog/categories/Tech/"><div class='name'>Tech</div><div class='badget'>39</div></a></li>
    
        <li><a class="flat-box" href="/blog/categories/Thinking/"><div class='name'>Thinking</div><div class='badget'>3</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/blog/tags/AI/" style="font-size: 14px; color: #808080">AI</a> <a href="/blog/tags/Consensus/" style="font-size: 14px; color: #808080">Consensus</a> <a href="/blog/tags/Copycat/" style="font-size: 14px; color: #808080">Copycat</a> <a href="/blog/tags/Deadlock/" style="font-size: 14px; color: #808080">Deadlock</a> <a href="/blog/tags/HBase/" style="font-size: 14px; color: #808080">HBase</a> <a href="/blog/tags/IMU/" style="font-size: 14px; color: #808080">IMU</a> <a href="/blog/tags/Learning/" style="font-size: 14px; color: #808080">Learning</a> <a href="/blog/tags/MVCC/" style="font-size: 14px; color: #808080">MVCC</a> <a href="/blog/tags/Mapreduce/" style="font-size: 14px; color: #808080">Mapreduce</a> <a href="/blog/tags/Mysql/" style="font-size: 14px; color: #808080">Mysql</a> <a href="/blog/tags/OOM/" style="font-size: 14px; color: #808080">OOM</a> <a href="/blog/tags/Raft/" style="font-size: 18.8px; color: #1a1a1a">Raft</a> <a href="/blog/tags/Uniqueness/" style="font-size: 14px; color: #808080">Uniqueness</a> <a href="/blog/tags/accelerometer/" style="font-size: 14px; color: #808080">accelerometer</a> <a href="/blog/tags/admission-control/" style="font-size: 14px; color: #808080">admission control</a> <a href="/blog/tags/amazon-aurora/" style="font-size: 14px; color: #808080">amazon aurora</a> <a href="/blog/tags/big-data/" style="font-size: 20px; color: #000">big data</a> <a href="/blog/tags/compaction/" style="font-size: 14px; color: #808080">compaction</a> <a href="/blog/tags/compass/" style="font-size: 14px; color: #808080">compass</a> <a href="/blog/tags/consistency/" style="font-size: 15.2px; color: #666">consistency</a> <a href="/blog/tags/credit-spread/" style="font-size: 14px; color: #808080">credit spread</a> <a href="/blog/tags/distributed/" style="font-size: 15.2px; color: #666">distributed</a> <a href="/blog/tags/elasticsearch/" style="font-size: 14px; color: #808080">elasticsearch</a> <a href="/blog/tags/flink/" style="font-size: 14px; color: #808080">flink</a> <a href="/blog/tags/git/" style="font-size: 15.2px; color: #666">git</a> <a href="/blog/tags/gyroscope/" style="font-size: 14px; color: #808080">gyroscope</a> <a href="/blog/tags/hbase/" style="font-size: 14px; color: #808080">hbase</a> <a href="/blog/tags/investment/" style="font-size: 15.2px; color: #666">investment</a> <a href="/blog/tags/links/" style="font-size: 14px; color: #808080">links</a> <a href="/blog/tags/lock/" style="font-size: 16.4px; color: #4d4d4d">lock</a> <a href="/blog/tags/mapreduce/" style="font-size: 15.2px; color: #666">mapreduce</a> <a href="/blog/tags/mysql/" style="font-size: 14px; color: #808080">mysql</a> <a href="/blog/tags/nginx/" style="font-size: 14px; color: #808080">nginx</a> <a href="/blog/tags/non-blocking/" style="font-size: 14px; color: #808080">non-blocking</a> <a href="/blog/tags/octave/" style="font-size: 14px; color: #808080">octave</a> <a href="/blog/tags/openstack/" style="font-size: 14px; color: #808080">openstack</a> <a href="/blog/tags/photography/" style="font-size: 14px; color: #808080">photography</a> <a href="/blog/tags/php/" style="font-size: 15.2px; color: #666">php</a> <a href="/blog/tags/quorum/" style="font-size: 14px; color: #808080">quorum</a> <a href="/blog/tags/rabbitmq/" style="font-size: 17.6px; color: #333">rabbitmq</a> <a href="/blog/tags/replication/" style="font-size: 14px; color: #808080">replication</a> <a href="/blog/tags/sbt/" style="font-size: 14px; color: #808080">sbt</a> <a href="/blog/tags/scala/" style="font-size: 14px; color: #808080">scala</a> <a href="/blog/tags/spark/" style="font-size: 14px; color: #808080">spark</a> <a href="/blog/tags/ssd/" style="font-size: 14px; color: #808080">ssd</a> <a href="/blog/tags/storage/" style="font-size: 14px; color: #808080">storage</a> <a href="/blog/tags/swift/" style="font-size: 14px; color: #808080">swift</a> <a href="/blog/tags/tool-collection/" style="font-size: 14px; color: #808080">tool collection</a> <a href="/blog/tags/transaction/" style="font-size: 14px; color: #808080">transaction</a> <a href="/blog/tags/国史大纲/" style="font-size: 14px; color: #808080">国史大纲</a> <a href="/blog/tags/洪业/" style="font-size: 14px; color: #808080">洪业</a> <a href="/blog/tags/认知/" style="font-size: 14px; color: #808080">认知</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/stkevintan" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/kevinsfork" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/blog/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/blog/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/blog/js/search.js"></script>
<script src="/blog/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
