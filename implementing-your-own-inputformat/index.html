<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Implementing Your Own Mapreduce Input Format · Liqun's Homepage</title><meta name="description" content="Implementing Your Own Mapreduce Input Format - Liqun Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon2.jpeg"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="liqul.github.io/blog/atom.xml" title="Liqun's Homepage"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon2.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives" target="_self" class="nav-list-link">TAGS/ARCHIVE</a></li><li class="nav-list-item"><a href="/blog/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Implementing Your Own Mapreduce Input Format</h1><div class="post-info">Feb 13, 2017</div><div class="post-content"><p>There are two steps for each input format, namely, getSplit and recordReader. GetSplit transforms the original input data into splits, one split for each mapper. Typically, if a big file is feed into mapreduce, it will be divided into splits of block size (e.g., 64M or 128M). However, if small files are provided, mapreduce will treat each file as a split. RecordReader turn each split into key value pairs, which are used by the mapper later. </p>
<p>In this article, I use several examples to explain how an inputformat be implemented. I’m greatly influenced by a few great references, such as <a href="http://www.idryman.org/blog/2013/09/22/process-small-files-on-hadoop-using-combinefileinputformat-1/" target="_blank" rel="noopener">this</a> and <a href="https://gist.github.com/airawat/6647007" target="_blank" rel="noopener">this</a>. </p>
<p>The first example is from book <a href="http://shop.oreilly.com/product/0636920033448.do" target="_blank" rel="noopener">“Hadoop: The Definitive Guide”</a>. WholeFileInputFormat treats each individual input file as a value. We do not need to implement our own getSplit function. Once the isSplitable function returns false, no file will be divided. Each file is treated as a split for the mapper. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WholeFileInputFormat extends FileInputFormat&lt;NullWritable, BytesWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isSplitable(JobContext context, Path filename) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RecordReader&lt;NullWritable, BytesWritable&gt; createRecordReader(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException &#123;</span><br><span class="line">        WholeFileRecordReader reader = new WholeFileRecordReader();</span><br><span class="line">        reader.initialize(inputSplit, taskAttemptContext);</span><br><span class="line">        return reader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since each file is a split, the inputSplit of the record reader is actually a FileSplit. In the example code below, each returned value is the whole content of the file. The key is null in this example, which can also be the name of the file obtained from the fileSplit. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class WholeFileRecordReader extends RecordReader&lt;NullWritable, BytesWritable&gt; &#123;</span><br><span class="line">  private FileSplit fileSplit;</span><br><span class="line">  private Configuration conf;</span><br><span class="line">  private BytesWritable value = new BytesWritable();</span><br><span class="line">  private boolean processed = false;</span><br><span class="line"></span><br><span class="line">  public void initialize(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException &#123;</span><br><span class="line">      this.fileSplit = (FileSplit) inputSplit;</span><br><span class="line">      this.conf = taskAttemptContext.getConfiguration();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean nextKeyValue() throws IOException, InterruptedException &#123;</span><br><span class="line">      if(!processed) &#123;</span><br><span class="line">          byte[] contents = new byte[(int)fileSplit.getLength()];</span><br><span class="line">          Path file = fileSplit.getPath();</span><br><span class="line">          FileSystem fs = file.getFileSystem(conf);</span><br><span class="line">          FSDataInputStream in = null;</span><br><span class="line">          try &#123;</span><br><span class="line">              in = fs.open(file);</span><br><span class="line">              IOUtils.readFully(in, contents, 0, contents.length);</span><br><span class="line">              value.set(contents, 0, contents.length);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              IOUtils.closeStream(in);</span><br><span class="line">          &#125;</span><br><span class="line">          processed = true;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public NullWritable getCurrentKey() throws IOException, InterruptedException &#123;</span><br><span class="line">      return NullWritable.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BytesWritable getCurrentValue() throws IOException, InterruptedException &#123;</span><br><span class="line">      return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public float getProgress() throws IOException, InterruptedException &#123;</span><br><span class="line">      return processed? 1.0f : 0.0f;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void close() throws IOException &#123;</span><br><span class="line">      //do nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I also think the TeraInputFormat a good example. The key difference from the previous example lies in the input file format of terasort. According to the document, each input element is a 100 byte array, with the first 10 bytes as key and the left 90 bytes as value. This raises a challenge for dividing the input file into splits with exactly multiple of 100 bytes. In the code below, the getSplits simply invokes super.getSplits, ignoring the format issue. Then, in the record reader, the offset is adjusted to the next multiple of 100. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public class TeraInputFormat extends FileInputFormat&lt;Text, Text&gt; &#123;</span><br><span class="line">    static final String PARTITION_FILENAME = &quot;_partition.lst&quot;;</span><br><span class="line">    private static final String NUM_PARTITIONS = &quot;mapreduce.terasort.num.partitions&quot;;</span><br><span class="line">    private static final String SAMPLE_SIZE = &quot;mapreduce.terasort.partitions.sample&quot;;</span><br><span class="line">    static final int KEY_LENGTH = 10;</span><br><span class="line">    static final int VALUE_LENGTH = 90;</span><br><span class="line">    static final int RECORD_LENGTH = 100;</span><br><span class="line">    private static MRJobConfig lastContext = null;</span><br><span class="line">    private static List&lt;InputSplit&gt; lastResult = null;</span><br><span class="line"></span><br><span class="line">    public TeraInputFormat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RecordReader&lt;Text, Text&gt; createRecordReader(InputSplit split, TaskAttemptContext context) throws IOException &#123;</span><br><span class="line">        return new TeraInputFormat.TeraRecordReader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;InputSplit&gt; getSplits(JobContext job) throws IOException &#123;</span><br><span class="line">        if(job == lastContext) &#123;</span><br><span class="line">            return lastResult;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            long t1 = System.currentTimeMillis();</span><br><span class="line">            lastContext = job;</span><br><span class="line">            lastResult = super.getSplits(job);</span><br><span class="line">            long t2 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;Spent &quot; + (t2 - t1) + &quot;ms computing base-splits.&quot;);</span><br><span class="line">            if(job.getConfiguration().getBoolean(TeraScheduler.USE, true)) &#123;</span><br><span class="line">                TeraScheduler scheduler = new TeraScheduler((FileSplit[])lastResult.toArray(new FileSplit[0]), job.getConfiguration());</span><br><span class="line">                lastResult = scheduler.getNewFileSplits();</span><br><span class="line">                long t3 = System.currentTimeMillis();</span><br><span class="line">                System.out.println(&quot;Spent &quot; + (t3 - t2) + &quot;ms computing TeraScheduler splits.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return lastResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TeraRecordReader extends RecordReader&lt;Text, Text&gt; &#123;</span><br><span class="line">        private FSDataInputStream in;</span><br><span class="line">        private long offset;</span><br><span class="line">        private long length;</span><br><span class="line">        private static final int RECORD_LENGTH = 100;</span><br><span class="line">        private byte[] buffer = new byte[100];</span><br><span class="line">        private Text key;</span><br><span class="line">        private Text value;</span><br><span class="line"></span><br><span class="line">        public TeraRecordReader() throws IOException &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException &#123;</span><br><span class="line">            Path p = ((FileSplit)split).getPath();</span><br><span class="line">            FileSystem fs = p.getFileSystem(context.getConfiguration());</span><br><span class="line">            this.in = fs.open(p);</span><br><span class="line">            long start = ((FileSplit)split).getStart();</span><br><span class="line">            this.offset = (100L - start % 100L) % 100L;</span><br><span class="line">            this.in.seek(start + this.offset);</span><br><span class="line">            this.length = ((FileSplit)split).getLength();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void close() throws IOException &#123;</span><br><span class="line">            this.in.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Text getCurrentKey() &#123;</span><br><span class="line">            return this.key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Text getCurrentValue() &#123;</span><br><span class="line">            return this.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public float getProgress() throws IOException &#123;</span><br><span class="line">            return (float)this.offset / (float)this.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean nextKeyValue() throws IOException &#123;</span><br><span class="line">            if(this.offset &gt;= this.length) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                long newRead;</span><br><span class="line">                for(int read = 0; read &lt; 100; read = (int)((long)read + newRead)) &#123;</span><br><span class="line">                    newRead = (long)this.in.read(this.buffer, read, 100 - read);</span><br><span class="line">                    if(newRead == -1L) &#123;</span><br><span class="line">                        if(read == 0) &#123;</span><br><span class="line">                            return false;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        throw new EOFException(&quot;read past eof&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(this.key == null) &#123;</span><br><span class="line">                    this.key = new Text();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(this.value == null) &#123;</span><br><span class="line">                    this.value = new Text();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.key.set(this.buffer, 0, 10);</span><br><span class="line">                this.value.set(this.buffer, 10, 90);</span><br><span class="line">                this.offset += 100L;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One of the most common reason of customizing your own input format is for combining small files into fewer bigger ones. For this purpose, we still need to disable the split of files. Note that the implemented CombineWholeFileInputFormat extends CombineFileInputFormat which helps to turn the input split into a combine file split (the size of each split could be tuned) which may contains multiple small files. Each individual file could be retrieved with an index as shown in the record reader below. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class CombineWholeFileInputFormat extends CombineFileInputFormat&lt;Text, BytesWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isSplitable(JobContext context, Path filename) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RecordReader&lt;Text, BytesWritable&gt; createRecordReader(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException &#123;</span><br><span class="line">        return new CombineFileRecordReader&lt;Text, BytesWritable&gt;(</span><br><span class="line">                (CombineFileSplit)inputSplit,</span><br><span class="line">                taskAttemptContext,</span><br><span class="line">                CombineWholeFileRecordReader.class</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CombineWholeFileRecordReader extends RecordReader&lt;Text, BytesWritable&gt; &#123;</span><br><span class="line">    private WholeFileRecordReader reader;</span><br><span class="line">    private String fileName;</span><br><span class="line">    public CombineWholeFileRecordReader(CombineFileSplit split, TaskAttemptContext context, Integer index) throws IOException, InterruptedException &#123;</span><br><span class="line">        FileSplit fileSplit = new FileSplit(split.getPath(index),</span><br><span class="line">                split.getOffset(index), split.getLength(index),</span><br><span class="line">                split.getLocations());</span><br><span class="line"></span><br><span class="line">        fileName = fileSplit.getPath().toString();</span><br><span class="line"></span><br><span class="line">        reader = new WholeFileRecordReader();</span><br><span class="line">        reader.initialize(fileSplit, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void initialize(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean nextKeyValue() throws IOException, InterruptedException &#123;</span><br><span class="line">        return reader.nextKeyValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Text getCurrentKey() throws IOException, InterruptedException &#123;</span><br><span class="line">        return new Text(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BytesWritable getCurrentValue() throws IOException, InterruptedException &#123;</span><br><span class="line">        return reader.getCurrentValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getProgress() throws IOException, InterruptedException &#123;</span><br><span class="line">        return reader.getProgress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() throws IOException &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="summary">Summary</span></h2><p>This article demonstrated a few sample implementations of input format for a mapreduce job. The basic idea is first divide the whole input data into splits and then read each split with a record reader. Usually, there are already plenty of base input formats that can be leveraged for customizing into more sophisticated ones.</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/running-mapreduce-over-openstack-swift/" class="prev">上一篇</a><a href="/blog/questions-applying-ai/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="liqul.github.io/blog">Liqun Li</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>